<?php

/**
 * Implements hook_upgrade_file_alter().
 *
 * Upgrades calls to class methods using grammar parser.
 *
 * @param PGPReader $reader
 *   The object containing the grammar statements of the file to convert.
 */
function development_upgrade_file_alter(&$reader) {
  // Get list of function calls (including the calls to class methods).
  $nodes = &$reader->getFunctionCalls();
  foreach ($nodes as &$node) {
    // Get the function call object.
    $item = &$node->data;
    if (!isset($item) || !is_object($item) || !is_a($item, 'PGPFunctionCall') || $item->type != T_FUNCTION_CALL) {
      // The reference could have been changed in another routine so that it
      // no longer refers to an ojbect.
      continue;
    }

    if (is_a($item->name, 'PGPOperand') && $item->name->findNode('value') == '$this') {
      $name = substr($item->name->toString(), 7); // Strip off '$this->'.
      development_convert_asserts($item, $reader, $name);
    }
  }
}

/**
* Implements hook_upgrade_call_alter().
*/
function development_convert_asserts(&$item, &$reader, &$name) {
  $ignore = array(
    'assertFieldSettings',
    'assertNodeAccess',
    'assertFailedLogin',
    'assertTableCount',
    'assertModules',
    'assertLogMessage',
    'assertFieldValues',
    'assertCommentOrder',
    'assertNothing',
    'assertModuleList',
    'assertCacheExists',
    'assertSessionCookie',
    'assertSessionEmpty',
    'assertFileUnchanged',
    'assertDifferentFile',
    'assertSameFile',
    'assertFileHooksCalled',
    'assertTags',
    'assertToolkitOperationsCalled',
    'assertErrorMessage',
    'assertNoErrorMessage',
    'assertUrlOutboundAlter',
    'assertUrlInboundAlter',
    'assertPaths',
    'assertReversePaths',
    'assertComponents',
    'assertWeights',
  );

  $zero_single = array(
    'assertCacheExists',
    'assertCacheRemoved',
    'assertAssertion',
  );

  $zero_normal = array(
    'pass',
    'fail',
    'error',
  );

  // All assert* not otherwise accounted for: $one.

  $two = array(
    'assertEqual',
    'assertNotEqual',
    'assertIdentical',
    'assertNotIdentical',
    'assertLink',
    'assertLinkByHref',
    'assertFieldByXPath',
    'assertNoFieldByXPath',
    'assertFieldByName',
    'assertNoFieldByName',
    'assertFieldById',
    'assertNoFieldById',
    'assertOptionSelected',
    'assertNoOptionSelected',
    'assertMail',

    // None DrupalTestCase assertions.
    'assertPathMatch',
    'assertNormalized',
    'assertNoNormalized',
    'assertSessionIds',
    'assertSameLink',
    'assertFilePermissions',
    'assertDirectoryPermissions',
    'assertFileHookCalled',
  );

  $four = array(
    'assertError',
  );

  // Function name.
//  $name = $item->name['value'];

  // Halt processing if call is to be ignored.
  if (in_array($name, $ignore)) {
    return;
  }

  $indices = array();

  // Determine the assertion format.
  if (in_array($name, $zero_single)) {
    // Format: message.
    $indices = array(0);
  }
  elseif (in_array($name, $zero_normal)) {
    // Format: message, group.
    $indices = array(0, 1);
  }
  elseif (in_array($name, $two)) {
    // Format: p1, p2, message, group.
    $indices = array(2, 3);
  }
  elseif (in_array($name, $four)) {
    // Format: p1, p2, p3, p4, message, group.
    $indices = array(4, 5);
  }
  elseif (strpos($name, 'assert') === 0) {
    // Format: p1, message, group.
    $indices = array(1, 2);
  }

  // Check if the function call is a recognized assertion.
  if (!empty($indices)) {
    // Cycle through the parameter indices to check, based on the assertion
    // format, and run the message extraction process.
    foreach ($indices as $index) {
      development_extract_message($item, $index);
    }
  }
}

/**
* Removes any wrapping t() function from the parameter at index.
*
* @param $item
*   PGP function call object.
* @param $index
*   Index of the parameter to check.
*/
function development_extract_message($item, $index) {
  if ($parameter = $item->getParameter($index)) {
    $operand = $parameter->findNode('operand');
    if (is_a($operand, 'PGPFunctionCall') && is_array($operand->name) && $operand->name['value'] == 't') {
      if ($operand->parameterCount() > 1) {
        $message = $operand->getParameter();
        $string = $operand->printParameter();
        $delimiter = $string[0];

        $args = development_get_value($operand, $operand->getParameter(1)->findNode('operand'));
        if (is_a($args, 'PGPAssignment')) {
          $variable = $operand->getParameter(1)->findNode('operand')->stripComments()->toString();

          $expression = $args->values->getElement();
          $replacements = $expression->getType('operand', 2); // The operand after the assignment operator.
          if ($replacements) {
            $i = 0;
            while ($key = $replacements->getKey($i)) {
//              cdp($key, '$key');
              $key = str_replace(array("'", '"'), '', $key->toString());
              $value = "{$variable}['$key']"; // $value = $replacements->getValue($i)->toString();
//              cdp($value, '$value');
              $string = str_replace($key, "$delimiter . " . $value . " . $delimiter", $string);
              $i++;
            }
          }
        }
        elseif (method_exists($args, 'getKey')) {
          $i = 0;
          while ($key = $args->getKey($i)) {
//            cdp($key, '$key');
            $key = str_replace(array("'", '"'), '', $key->toString());
            $value = $args->getValue($i)->toString();
            $string = str_replace($key, "$delimiter . " . $value . " . $delimiter", $string);
            $i++;
          }
        }
        $message = PGPEditor::getInstance()->expressionToStatement($string);
        $item->setParameter($index, $message);
      }
    }
  }
}

/**
 * Returns the array or assignment statement with replacement values for t().
 *
 * @param PGPFunctionCall $operand
 * @param object $item
 *   The replacement values parameter to the t() call.
 *
 * @return object
 *   The replacement values parameter (if an array) or the most recent
 *   assignment statement to the replacement variable.
 */
function development_get_value($operand, $item) {
//  cdp(__FUNCTION__);
  if (is_a($item, 'PGPOperand') && $item->findNode('type') == T_VARIABLE) {
    cdp('operand is a T_VARIABLE');
    clp('operand is a T_VARIABLE');
    // The replacement values parameter is a variable.
    // Find the most recent assignment to this variable and return it.
    // (Note: this search is limited to the function containing the assertion.)
    // Opportunistically hope for a single assignment to the variable, e.g.
    // $replacements = array('key1' => 'value1, ...);
    // Set current to avoid messing with the value of $operand->parent which causes failure.
    $current = $operand->parent;
    $statement = $operand->parent->container->searchBackward('PGPAssignment', 'values', 0, $item->findNode('value'), $current);
//    cdp($statement->toString(), '$statement');
    return $statement ? $statement : $item;
  }
  else {
    // Hopefully, the replacement values parameter is an array.
    return $item;
  }
}
